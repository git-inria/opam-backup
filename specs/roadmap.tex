\documentclass[a4paper,11pt]{article}

\usepackage{url}
\usepackage{eurosym}
%\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{pdfswitch}
\usepackage{verbatim}
\usepackage{fullpage}
\usepackage{fancyvrb}

\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\title{
OPAM: a Package Management Systems for OCaml\\
Version 1.0.0 Roadmap\\ ~\ \\
THIS DOCUMENT IS A DRAFT\\
~\ \\}
\author{Thomas GAZAGNAIRE\\
\url{thomas.gazagnaire@ocamlpro.com}\\
}

\begin{document}

\maketitle

\vfill

\tableofcontents

\section*{Overview}

This document specifies the design of a package management system for
OCaml (OPAM). For the first version of OPAM, we have tried to consider
the simplest design choices, even if these choices restrict user
possibilities (but we hope not too much). Our goal is to propose a
system that we can build in a few months. Some of the design choices
might evolve to more complex tasks later, if needed. \\

A package management system has typically two kinds of users: {\em
  end-users} who install and use packages for their own projects; and
{\em packagers}, who create and upload packages. End-users want to
install on their machine a consistent collection of {\em packages} --
a package being a collection of OCaml libraries and/or programs.
Packagers want to take a collection of their own libraries and
programs and make them available to other developpers.

This document describes the fonctional requirements for both kinds of
users.

\subsection*{Conventions}

In this document, {\tt \$home}, {\tt \$opam}, {\tt \$opamserver} and
{\tt \$package} are assumed to be defined as follows:

\begin{itemize}

\item {\tt \$home} refers to the end-user home path, typically {\tt
  /home/thomas/} on linux, {\tt /Users/thomas/} on OSX {\tt
  C:\textbackslash Documents and Settings\textbackslash
  thomas\textbackslash} on Windows.

\item {\tt \$opam} refers to the filesystem subtree containing the
  client state. Default directory is {\tt \$home/.opam}.

\item {\tt \$opamserver} refers to the filesystem subtree containing
  the server state. Default directory is {\tt \$home/.opam-server}.

\item {\tt \$package} refers to a path in the packager filesystem, where
  lives the collection of libraries and programs he wants to package.

\end{itemize}

User variables are written in capital letters, prefixed by \verb+$+. For
instance package names will be written \verb+$NAME+, package versions
\verb+$VERSION+, and the version of the ocaml compiler currently
installed \verb+$OVERSION+.

\section{Milestone 1: Foundations}

The first milestone of OPAM focuses on providing a limited set of
features, dedicated to package management of OCaml packages. OPAM rely
on external tools to compile and provide full configuration options to
the build tools. The goal for this first milestone is to be compatible
with {\tt ocamlfind} and {\tt oasis}.

\subsection{Client state}
\label{client}

The client state is stored on the filesystem, under {\tt \$opam}:

\begin{itemize}

\item {\tt \$opam/config} is the main configuration file. It defines
  the OPAM version, the repository addresses and the current compiler
  version. The file format is described in \S\ref{config}.

\item \verb+$opam/index/$NAME.$VERSION.opam+ is the OPAM specification
  for the package \verb+$NAME+ with version \verb+$VERSION+ (which
  might not be installed). The format of OPAM files is described in
  \S\ref{opam}.

\item \verb+$opam/descr/$NAME.$VERSION+ is the textual description of
  the version \verb+$VERSION+ of package \verb+$NAME+ (which might not
  be installed). The first line of this file is the package synopsis.

\item \verb+$opam/$OVERSION/installed+ is the list of installed
  packages for the compiler version \verb+$OVERSION+. The file format
  is described in \S\ref{installed}.

\item \verb+$opam/$OVERSION/config/$NAME.config+ is a
  platform-specific configuration file of for the installed package
  \verb+$NAME+ with the compiler version \verb+$OVERSION+. The file
  format is described in \S\ref{pconfig}.
  \verb+$opam/$OVERSION/config/+ can be shortened to \verb+$config/+
  for more readability.

\item \verb+$opam/$OVERSION/install/$NAME.install+ is a
  platform-specific package installation file for the installed
  package \verb+$NAME+ with the compiler version \verb+$OVERSION+. The
  file format is described in \S\ref{install}.
  \verb+$opam/$OVERSION/install+ can be shortened to \verb+$install/+
  for more readability.

\item \verb+$opam/$OVERSION/lib/$NAME/+ contains the libraries
  associated to the installed package \verb+$NAME+ with the compiler
  version \verb+$OVERSION+. \verb+$opam/$OVERSION/lib/+ can be
  shortened to \verb+$lib/+ for more readability.

\item \verb+$opam/$OVERSION/doc/$NAME/+ contains the documentation
  associated to the installed package {\tt NAME} with the compiler
  version \verb+$OVERSION+. /\verb+$opam/OVERSION/doc/+ can be
  shortened to \verb+$doc/+ for more readability.

\item \verb+$opam/$OVERSION/bin/+ contains the program files for all
  installed packages with the compiler version
  \verb+$OVERSION+. \verb+$opam/$OVERSION/bin/+ can be shortened to
  \verb+$bin/+ for more readability.

\item \verb+$opam/archives/$NAME.$VERSION.tar.gz+ contains the archive
  of source files for the version \verb+$VERSION+ of package
  \verb+$NAME+.

\item \verb+$opam/$OVERSION/build/$NAME.$VERSION/+ is a tempory folder
  used to build package \verb+$NAME+ with version \verb+$VERSION+,
  with compiler version \verb+$OVERSION+.\verb+$opam/$OVERSION/build/+
  can be shortened to \verb+$build/+ for more readability.

\end{itemize}

\subsection{File syntax}

\subsubsection{Installed packages}
\label{installed}

\verb+$opam/$OVERSION/installed+ follows a very simple syntax: the
file is a list of lines which contains a name and a version, separated
by a single space. Each line \verb+$NAME $VERSION+ means that the
version \verb+$VERSION+ of package \verb+$NAME+ has been compiled with
OCaml version \verb+$OVERSION+ and has been installed on the system in
\verb+$lib/$NAME+ and \verb+$bin/+. \\

For instance, if {\tt batteries} version {\tt 1.0+beta} and {\tt
  ocamlfind} version {\tt 1.2} are installed, then
\verb+$opam/$OVERSION/installed+ will contain:

{\small
\begin{Verbatim}[frame=single]
batteries 1.0+beta
ocamlfind 1.2
\end{Verbatim}
}

\subsubsection{General syntax}
\label{syntax}

Most of the files in the client and server states share the same
syntax defined in this section.

\begin{description}

\item[Base types] The base types for values are:

\begin{itemize}
\item {\tt BOOL} is  either {\tt true} or {\tt false}
\item {\tt STRING} is a doubly-quoted OCaml string, for instance: {\tt
  "foo"}, {\tt "foo-bar"}, $\ldots$
\item {\tt SYMBOL} contains only non-letter and non-digit characters,
  for instance: {\tt =}, {\tt <=}, $\ldots$ Some symbols have a special
  meaning and thus are not valid {\tt SYMBOL}s: \verb+(+ \verb+)+
  \verb+[+ \verb+]+ \verb+{+ \verb+}+ \verb+:+
\item {\tt IDENT} starts by a letter and is followed by any number of
  letters, digit and symbols, for instance: {\tt foo}, {\tt foo-bar},
  $\ldots$. 
\end{itemize}


\item[Compound types] Types can be composed together to build more
  complex values:

\begin{itemize}
\item {\tt X Y } is a space-separated pair of value.
\item {\tt X | Y } is a value of type either {\tt X} or {\tt Y}.
\item {\tt ?X} is zero or one occurrence of a value of type {\tt X}.
\item {\tt X+} is a space-separated list of values of at least one value
  of type {\tt X}.
\item {\tt X*} is a space-separated list of values of values of type
  {\tt X} (it might contain no value).
\end{itemize}

\end{description}

All structured OPAM files share the same syntax:

{\small
\begin{Verbatim}[frame=single]
<value> := BOOL
         | STRING
         | SYMBOL
         | IDENT
         | [ <value>+ ]
         | value ( <value>+ )

<item> := IDENT : <value>
        | ?IDENT: <value>
        | IDENT STRING { <item>+ }

<file>  := <item>*
\end{Verbatim}
}

\subsubsection{Configuration files}
\label{config}

\verb+$opam/config+ follows the syntax defined in \S\ref{syntax} with
the following restrictions:

{\small
\begin{Verbatim}[frame=single]
<file> :=
    opam-version: "1.0"
    sources:      [ STRING* ]
    ocaml-version: STRING
\end{Verbatim}
}

The field {\tt sources} contains the list of OPAM
repositories\footnote{default is {\tt
    "http://opam.ocamlpro.com/pub/"}}. Initially, the field {\tt
  ocaml-version} corresponds to the output of {\tt 'ocamlc -version'}.

\subsubsection{OPAM files}
\label{opam}

\verb+$opam/index/$NAME.$VERSION.opam+ follows the syntax defined in
\S\ref{syntax} with the following restriction:

{\small
\begin{Verbatim}[frame=single]
<file> :=
    opam-version: 1.0
    package NAME {
      version:    STRING
      maintainer: STRING
      ?build:     [ command+ ]
      ?depends:   <formula>
      ?conflicts: <formula>
      ?libraries: [ STRING+ ]
      ?syntax:    [ STRING+ ]
    }

<formula>    := STRING
              | STRING ( <constraint> )
              | <formula> '|' <formula>
              | <formula> '&' <formula>
              | ( <formula> )

<constraint> := <comp> STRING
              | <constraint> '|' <constraint>
              | <constraint> '&' <constraint>
              | ( <constraint> )

<comp>       := '=' | '<' | '>' | '>=' | '<='
<command>    := [ STRING+ ]
\end{Verbatim}
}

\begin{itemize}

\item The first line specifies the OPAM version.

\item The contents of {\tt version} is \verb+$VERSION+. The content of
  {\tt maintainer} is the contact address of the package maintainer.

\item The content of {\tt build} is the list of commands to run in
  order to build the package libraries. The build script should build
  all the libraries and syntax extensions exported by the package and
  it should produce the platform-specific configuration and install
  files \verb+$NAME.config+ and \verb+$NAME.install+ (see
  \S\ref{pconfig} and \S\ref{install}).

\item The {\tt depends} and {\tt conflicts} fields contain expressions
  over package names, optionally parametrized by version
  constrains. An expression is either:

\begin{itemize}
\item A package name: {\tt "foo"};
\item A package name with version constraints:
  \verb+"foo" (>= "1.2" & <= "3.4")+
\item A disjunction of expressions: \verb+E | F+
\item A conjunction of expressions: \verb+E & F+
\item An expression with parenthesis: \verb+( E )+
\end{itemize}

For instance \verb+ "foo" (<= "1.2") & ("bar" | "gna" (= "3.14"))+
is a valid formula whose semantic is: {\em a version of package
  {\tt "foo"} lesser or equal to $1.2$ and either any version of
  package {\tt "bar"} or the version $3.14$ of package {\tt "gna"}.}
\\

\item The {\tt libraries} and {\tt syntax} fields contain the
  libraries and syntax extensions defined by the package.

\end{itemize}

\subsubsection{Configuration files}
\label{pconfig}

\verb+$opam/OVERSION/config/NAME.config+ follows the syntax defined in
\S\ref{syntax}, with the following restrictions:

{\small
\begin{Verbatim}[frame=single]
<file>  := <item>*
<item>  := <def> | <block>
<block> :=
    <kind> STRING {
      ?asmcomp:  [ STRING+ ]
      ?bytecomp: [ STRING+ ]
      ?asmlink : [ STRING+ ]
      ?bytelink: [ STRING+ ]
      ?requires: [ <dep>+ ]
      <def>*
    }
<dep>   := STRING 
         | STRING ( STRING+ )
<kind>  := library | syntax
<def>   := IDENT: BOOL
         | IDENT: STRING
         | IDENT: [ STRING+ ]
\end{Verbatim}
}

\verb+$NAME.config+ contains platform-dependent information which can
be useful for other libraries or syntax extensions wants to use
libraries defined in the package \verb+$NAME+.

\paragraph{Local and global variables}

The definitions {\tt IDENT: BOOL}, {\tt IDENT: STRING} and {\tt IDENT:
  [ STRING+ ]}, are used to defined variables associated to this
package, and are used to substitute variables in template files (see
\S\ref{subst}):

\begin{itemize}

\item \verb+%{$NAME}$VAR%+ will refer to the variable \verb+$VAR+
  defined at the root of the configuration file \verb+$config/NAME.config+.

\item \verb+%{$NAME.$LIB}$VAR%+ will refer to the variable \verb+$VAR+
  defined in the library or syntax block named \verb+$LIB+ in the
  configuration file \verb+$config/$NAME.config+.

\end{itemize}

\paragraph{Library and syntax and blocks}

Each {\tt library} block defines the specific compilation flags to
enable when using and linking with this library.

\begin{itemize}
\item {\tt asmcomp} are compilation options to give to the native
  compiler (when using the {\tt -c} option)
\item {\tt bytecomp} are compilation options to give to the bytecode
  compiler (when using the {\tt -c} option)
\item {\tt asmlink} are linking options to give to the native compiler 
\item {\tt bytlink} are linking options to give to the bytecode
  compiler
\item {\tt requires} is the list of libraries and syntax extensions
  the current block is depending on. The full list of compilation
  and linking options is built by looking at the transitive closure of
  dependencies.

  The contents of {\tt deps} is either:
  \begin{itemize}
  \item {\tt "foo"} the block is depending on all the syntax
    extensions and libraries defined in the package {\tt "foo"}; or
  \item {\tt "foo" ("bar" "gna")} the block is depending only on the
    libraries {\tt "bar"} and {\tt "gna"} defined in the package {\tt
      "foo"}.
  \end{itemize}
\end{itemize}

The distinction between libraries and syntax extensions is only useful
at compile time to know whether the options should be used as
compilation or pre-processing arguments.

\subsubsection{Install files}
\label{install}

\verb+$opam/OVERSION/install/NAME.install+ follows the syntax defined
in \S\ref{syntax}, but restricted to the following subset:

{\small
\begin{Verbatim}[frame=single]
<file> :=
    ?lib:  [ STRING+ ]
    ?bin:  [ <mv>+ ]
    ?doc:  [ STRING+ ]
    ?misc: [ <mv>+ ]

<mv> := STRING
      | STRING ( STRING )
\end{Verbatim}
}

\begin{itemize}
\item Files listed under {\tt lib} are copied to \verb+$lib/$NAME/+.
\item Files listed under {\tt bin} are copied to \verb+$bin/+ (they
  can be renamed using \verb+$SRC ( $DST )+; in this case \verb+$SRC+
  should be a simple filename, ie. it should not start with a
  directory name).
\item Files listed under {\tt doc} are copied to \verb+$doc/$NAME/+.
\item Files listed under {\tt misc} should be processed as follows:
  for each pair \verb+$SRC ( $DST )+, the tool should ask the user if
  he wants to install \verb+$SRC+ to the absolute path \verb+$DST+.
\end{itemize}

\subsubsection{Substitution files}
\label{subst}

All of the previous files can be generated using a special mode of
{\tt opam} which can perform tests and substitutes variables (see
\S\ref{opam-config} for the exact command to run). Substitution files
contains some templates which will be replaced by some contents. The
syntax of templates is the following:

\begin{itemize}

\item templates such as \verb+%{$NAME}$VAR%+ are replaced by the value
  of the variable \verb+$VAR+ defined at the root of the file
  \verb+$config/NAME.config+.

\item templates such as \verb+%{$NAME.$LIB}$VAR%+ are replaced by the
  value of the variable \verb+$VAR+ defined in the \verb+$LIB+ section
  in the file \verb+$config/PACKAGE.config$+

%% \item templates such as \verb+%{IF $test %{ $then %} THEN %{ $else %}}+ are
%%    replaced by \verb+$then+ if \verb+$test+ is either:
%% \begin{itemize}
%% \item the ident {\tt true}
%% \item or a (global or local) variable whose value is the ident {\tt
%%   true}
%% \item or an expression \verb+$var1 = $var2+ or \verb+$var = STRING+ 
%%   where the contents of both sides of {\tt =} evaluates to the same
%%   value.
%% \end{itemize}
%% Otherwise, the template is replaced by \verb+$else+.

\end{itemize}

\subsection{Client commands}

\subsubsection{Creating a fresh client state}

When an end-user starts OPAM for the first time, he needs to
initialize \verb+$opam/+ in a consistent state. In order to do so, he
should run:

\begin{verbatim}
    $ opam init $HOSTNAME
\end{verbatim}

Where \verb+$HOSTNAME+ is the initial OPAM repository.  If no OPAM
repository is specified, default is
\verb+"http://opam.ocamlpro.com/pub"+.

This command will:

\begin{enumerate}

\item create the file \verb+$opam/config+ (as specified in
  \S\ref{pconfig})

\item create an empty \verb+$opam/$OVERSION/installed+ file.

\item download the OPAM files available at \verb+$HOSTNAME/index/+ into
  \verb+$opam/index/+

\item download the description files available at
  \verb+$HOSTNAME/descr/+ into \verb+$opam/index/+

\item create the empty directories \verb+$opam/archives+,
  \verb+$lib/+, \verb+$bin/+ and \verb+$doc+.

\end{enumerate}

\subsubsection{Listing packages}

When an end-user wants to have information on all available packages,
he should run:

\begin{verbatim}
    $ opam list
\end{verbatim}

This command will parse \verb+$opam/$OVERSION/installed+ to know the
installed packages, and \verb+$opam/index/*.opam+ to get all the
available packages. It will then build a summary of each packages. The
description of each package will be read in \verb+$opam/descr/+ if it
exists.

For instance, if {\tt batteries} version {\tt 1.1.3} is installed,
{\tt ounit} version {\tt 2.3+dev} is installed and {\tt camomille} is
not installed, then running the previous command should display:

\begin{verbatim}
    batteries   1.1.3  Batteries is a standard library replacement
    ounit     2.3+dev  Test framework
    camomille      --  Unicode support
\end{verbatim}

\subsubsection{Getting package info}

In case the end-user wants a more details view of a specific package,
he should run:

\begin{verbatim}
    $ opam info $NAME
\end{verbatim}

This command will parse \verb+$opam/$OVERSION/installed+ to get the
installed version of \verb+$NAME+ and will look for
\verb+$opam/index/$NAME.*.opam+ to get available versions of
\verb+$NAME+. It can then display:

\begin{verbatim}
    package: $NAME
    version: $VERSION                 # '--' if not installed
    versions: $VERSION1, $VERSION2, ...
    libraries: $LIB1, $LIB2, ...
    syntax: $SYNTAX1, $SYNTAX2, ...
    description:
      $SYNOPSIS

      $LINE1
      $LINE2
      $LINE3
      ...
\end{verbatim}

\subsubsection{Installing a package}
\label{opam-install}

When an end-user wants to install a new package, he should run:

\begin{verbatim}
    $ opam install $NAME
\end{verbatim}

This command will:

\begin{enumerate}

\item compute the transitive closure of dependencies and conflicts of
  packages using the dependency solver (see \S\ref{deps}). If the
  dependency solver returns more than one answer, the tool will ask
  the user to pick one, otherwise it will proceed directly. The
  dependency solver should also mark the packages to recompile.

\item the dependency solver sorts the collections of packages in
  topological order. Them, for each of them do:

\begin{enumerate}

\item check whether the package is already installed by looking for
  the line \verb+$NAME $VERSION+ in \verb+$opam/$OVERSION/installed+.
  If not, then:

\item look into the archive cache to see whether it has already been
  downloaded. The cache location is:
  \verb+$opam/archives/$NAME.VERSION.tar.gz+

\item if not, find a repository where the archive is available,
  download the archive and store it in the cache. The process to query
  a repository and get a package archive is described in
  \S\ref{repository}.

\item decompress the archive into \verb+$build/$NAME.$VERSION/+.

\item run the list of commands to build the package.

\item process \verb+$build/$NAME.$VERSION/$NAME.install+ to install
  the created files. The file format is described in \S\ref{install}.

\item install \verb+$build/$NAME.$VERSION/$NAME.install+ and
  \verb+$build/$NAME.$VERSION/$NAME.config+ at the right place (ie. in
  \verb+$install+ and in \verb+$config+)

\end{enumerate}
\end{enumerate}

\begin{remark}
\end{remark}

\subsubsection{Updating index files}

When an end-user wants to know what are the latest packages available,
he will write:

\begin{verbatim}
    $ opam update
\end{verbatim}

This command will ask all the repositories the list of available
packages (see \S\ref{repository}).

\subsubsection{Upgrading installed packages}

When an end-user wants to upgrade the packages installed on his host,
he will write:

\begin{verbatim}
    $ opam upgrade
\end{verbatim}

This command will call the dependency solver (see \S\ref{deps}) to
find a consistent state where {\em most} of the installed packages are
upgraded to their latest version. It will install each non-installed
packages in topological order, similar to what it is done during the
install step, See \S\ref{install}.

\subsubsection{Getting package configuration}
\label{opam-config}

The first version of OPAM contains the minimal information to be able
to use installed libraries. In order to do so, the end-user (or the
packager) should run:

\begin{verbatim}
    $ opam config -list-vars
    $ opam config -var {$NAME}$VAR
    $ opam config -var {$NAME.$LIB}$VAR
    $ opam config -subst $FILENAME+
    $ opam config [-r] -I        $NAME+
    $ opam config [-r] -bytecomp $NAME.$LIB+
    $ opam config [-r] -asmcomp  $NAME.$LIB+
    $ opam config [-r] -bytelink $NAME.$LIB+
    $ opam config [-r] -asmlink  $NAME.$LIB+
\end{verbatim}

\begin{itemize}
\item \verb+-list-vars+ will return the list of all variables defined
  in installed packages (see \S\ref{pconfig})
\item \verb+-var $var+ will return the value associated to the
  variable \verb+$var+
\item \verb+-subst $FILENAME+ replace any occurrence of
  \verb+%{$NAME}$VAR%+ and \verb+%{$NAME.$LIB}$VAR%+ as specified in
  \S\ref{subst} in \verb+$FILENAME.in+ to create \verb+$FILENAME+.
\item \verb+-I $NAME+ will return the list of paths to include when
  compiling a project using the package \verb+$NAME+ (\verb+-r+ gives
  a result taking into account the transitive closure of
  dependencies).
\item \verb+-bytecomp+, \verb+-asmcomp+, \verb+-bytelink+ and
  \verb+-asmlink+ return the associated value for the section
  \verb+$LIB+ in the file \verb+$config/$NAME.config+ (\verb+-r+ gives
  a result taking into account the transitive closure of all
  dependencies).
\end{itemize}


\subsubsection{Uploading packages}
\label{upload}

When a packager wants to create a package, he should:

\begin{enumerate}

\item create \verb+$package/$NAME.$VERSION.opam+ containing in the format
  specified in \S\ref{opam}.

\item create a file describing the package

\item make sure the command scripts:
\begin{itemize}
\item build the libraries and packages advertised in
  \verb+$package/$NAME.$VERSION.opam+
\item generates a valid \verb+$package/$NAME.install+ containing the
  list of files to install (the file format is described in
  \ref{install}).
\item generates a valid \verb+$package/$NAME.config+ containing the
  configuration flags for libraries exported by this package (the file
  format is described in \ref{config})
\end{itemize}

\item create an archive \verb+$NAME.$VERSION.tar.gz+ of the sources he
  wants to distribute.

\item run the following command:

\begin{verbatim}
    $ opam upload -opam $OPAM -descr $DESC -archive $ARCHIVE [-repo $REPO]+
\end{verbatim}

This command looks into the current directory for the files named 
\verb+$OPAM$+, \verb+$DESC+ and \verb+$ARCHIVE+.
It will parse \verb+$OPAM+ to get the package name and version
number and checks that \verb+$ARCHIVE$+ is
\verb+$NAME.$VERSION.tar.gz+. It will then ask either only the
specified repositories or all the available repositories to update the
files upstream, as described in \S\ref{repository}.

It is understood that this command will work only for writable
repositories.

\end{enumerate}

\subsection{Removing packages}

When the user wants to remove a package, he should write:

\begin{verbatim}
    $ opam remove $NAME
\end{verbatim}

This command will check whether the package \verb+$NAME+ is installed,
and if yes, it will display to the user the list packages that will be
uninstalled (ie. the transitive closure of all forward-dependencies).
If the user accepts the list, all the packages should be uninstalled,
and the client state should be let in a consistent state.

\subsection{Dependency solver}
\label{deps}

Dependency solving is a hard problem and we do not plan to start from
scratch implementing a new SAT solver. Thus our plan to integrate (as
a library) the Debian depency solver for CUDF files, which is written
in OCaml.

\begin{itemize}
\item the dependency solver should run on the client; and
\item the dependency solver should take as input a list of packages
  (with some optional version information) the user wants to install,
  upgrade and remove and it should return a consistent list of
  packages (with version numbers) to install, upgrade, recompile and
  remove.
\end{itemize}

\subsection{OPAM repositories}

\subsubsection{Server state}

The filesystem of OPAM repositories are mirrored on the client
filesystem under \verb$opamserver/$HOSTNAME+ for each remote
repository named \verb+$HOSTNAME+. This filesystem contains:

\begin{itemize}

\item \verb+$opamserver/$HOSTNAME/index/$NAME.$VERSION.opam+, which are
  OPAM files for all available versions of all available packages. The
  format of specification files is described in \S\ref{opam}.

\item \verb+$opamserver/$HOSTNAME/descr/$NAME.$VERSION+, which are
  textual description files for all available versions of all
  available packages.

\item \verb+$opamserver/scripts+ contains the script that the client
  will run to send requests to the repository

\end{itemize}

\subsubsection{Server scripts}

Each repository might implement a different logic to update and upload
packages. For instance, it can be a simple {\tt rsync} command or
more complex {\tt git} scripts).

The client will assume there is at least three scripts available in
the server repository:

\begin{itemize}

\item \verb+$opamserver/scripts/init+ the script will be run after to
  build the initial state of the repository

\item \verb+update+ the script which will be run each
  time the repository is updated. It should return a list of lines
  following the same format as described in \S\ref{installed} and
  containing the new packages.

\item \verb+$opamserver/getArchive+ is a script which will be run to
  get an the archive corresponding to a package. It takes as argument
  a package name and a package version and it returns the downloaded
  filename.

\item \verb+$opamserver/setArchive+ is a script which will be run
  to upload a new archive. It takes as argument a package name, a
  package version and the archive to upload.

\end{itemize}

\section{Milestone 2: Custom Client-Server Protocol}
\label{api}

All the kinds of OPAM repositories should be available using the same
API (however, some functions will not be available for some backends).

\subsubsection{Getting the list of packages}

\label{getList}
\begin{verbatim}
    val getList   : repo -> (name * version) list 
    val updateList: repo -> (name * version) list
\end{verbatim}

\verb+getList $HOSTNAME+ returns the full list of available packages. This
command is intended to be run only once, when the repository
\verb+$HOSTNAME+ is initialized.\\

\verb+updateList $HOSTNAME+ updates the given repository and returns
the list of newly available packages. For repositories not using the
custom OPAM protocol (eg. not starting by \verb+opam://+) this means
running the script \verb+$opamserver/$HOSTNAME/update+ which should
return a list of lines of (package name, version) pairs using the same
format as described in \S\ref{installed}.

\subsubsection{Getting OPAM files}
\label{getOPAM}

\begin{verbatim}
    val getOPAM: repo -> (name * version) -> opam
\end{verbatim}

{\tt getOPAM repo (name,version)} returns the corresponding OPAM
filename as an absolute location in the filesystem (which should be .

\subsubsection{Getting description files}
\label{getOPAM}

\begin{verbatim}
    val getDescr: repo -> (name * version) -> descr
\end{verbatim}

{\tt getDescr repo (name,version)} returns the corresponding
description file.

\subsubsection{Getting package archive}
\label{getArchive}

\begin{verbatim}
    val getArchive: repo -> (name * version) -> archive
\end{verbatim}

{\tt getArchive repo (name,version)} returns the corresponding package
archive.

\subsubsection{Uploading new archives}
\label{newArchive}

\begin{verbatim}
    val newArchive: repo -> (opam * archive) -> unit
\end{verbatim}

{\tt newArchive(opam,archive)} takes as input an OPAM file and the
corresponding package archive, and upload the server state. This
function works only for READ-WRITE repository. In case of a READ-ONLY
one, a suitable error message is returned to the user.

\subsubsection{Binary Protocol}

In case of READ-WRITE repositories, the server state can be queried
and modified by any OPAM clients, using the following binary protocol

\begin{itemize}

\item Communication between clients and servers always start by an
hand-shake to agree on the protocol version.

\item All the basic values (names, versions and binary data) are
  represented as OCaml strings.

\item More complex values are marshaled using a simple binary
  protocol: the first byte represents the message number, and then
  each message argument is stacked in the message with its size as
  prefix. The list of messages {\em from the client to server} is:

{\small
\begin{tabular}{|l|l|l|}
\hline
Client-to-Server Message & Arguments & Description \\
\hline
\hline
\verb+GetList+ & -- & Ask for the list of all OPAM files \\
\hline
\verb+GetOPAM+ & \verb+name   : string+ & Ask for the binary representation of \\
               & \verb+version: string+ & a given OPAM file \\
\hline
\verb+GetArchive+ & \verb+name   : string+ & Ask for the binary representation of \\
                  & \verb+version: string+ & a given archive file \\
\hline
\verb+NewArchive+ & \verb+name   : string+ & Create a new package on the
server. \\
                  & \verb+version: string+ & The client should provide
the OPAM file \\
                  & \verb+opam   : string+ & and the source archive. \\
                  & \verb+archive: string+ & \\
\hline
\verb+UpdateArchive+ &  \verb+name   : string+ & Update a new version
of a given \\
                  & \verb+version: string+ & package on the
server. The client \\
                  & \verb+opam   : string+ & should also provide a security key\\
                  & \verb+archive: string+ & \\
                  & \verb+key    : string+ & \\
\hline
\end{tabular}
}

\item Answers from the server are encoded in the same way (ie, a byte
  for the message number, followed by optional arguments prefixed by
  their size). List arguments are encoded by stacking first the
  lenght, and then all the elements of the list in sequential order.
  The list of messages {\em from servers to clients} is:

{\small
\begin{tabular}{|l|l|l|}
\hline
Server-to-Client Message & Arguments & Description \\
\hline
\hline
\verb+GetList+      & \verb+list   : (string*string) list+ & Return the list
of available \\
 & & package names and versions \\
\hline
\verb+GetOPAM+      & \verb+opam   : string+ & Return an OPAM file \\
\hline
\verb+GetArchivwe+  & \verb+archive: string+ & Return an archive file \\
\hline
\verb+NewArchive+   & \verb+key    : string+ & Return a security key \\
\hline
\verb+UpdateArchive+& --                     & The update went OK \\
\hline
\verb+Error+        & \verb+error  : string+ & An error occurred \\
\hline
\end{tabular}
}

\end{itemize}

Note that when an error is raised by an arbitrary function
 at server side, the client receives \verb|Error _|.



\section{Milestone 3: Link Information}

This milestone focuses on adding the right level of linking
information, in order to be able to use packages more easily.


\section{Milestone 4: Server Authentication}

This version focuses on server authentication.

\subsection{RPC protocol}

The protocol should be specified (using either a binary format or a
JSON format).

\subsection{Server authentication}

The server should be able to ask for basic credential proofs. The
protocol can be sketched as follows:

\begin{itemize}

\item packagers store keys in {\tt \$opam/keys/NAME}. These keys are
  random strings of size 128.

\item the server stores key hashes in {\tt
  \$opamserver/hashes/NAME}.

\item when a packager wants to upload a fresh package, he still uses
  {\tt newArchive}. However, the return type of this function is
  changed in order to return a random key. OPAM clients then stores
  that key in {\tt \$opam/keys/NAME}.

\item when a packager wants to uplaod a new version of an existing
  package, he uses the function {\tt val updateArchive: (opam * string
    * string) -> bool}. {\tt updateArchive} takes as argument an OCaml
  value representing the OPAM file contents, the archive file as a
  binary string and the key as a string. The server then checks
  whether the hash of the key is equal to the one stored in {\tt
    \$opamserver/hashes/NAME}; if yes, it updates the
  package and return {\tt true}, if no if it returns {\tt false}.

\item packager email should be specified in {\tt NAME.opam}:

\end{itemize}

\section{Milestones 6: Pre-Processors Information}

This milestone focus on the support of pre-processors.

\subsection{Getting package preprocessor options}

The user should be able to run:

\begin{verbatim}
    $ opam-config -bytepp NAME
    $ opam-config -asmpp NAME
\end{verbatim}

This command will return the command line option to build the
preprocessor exported by package {\tt NAME}.

In order to do so, packagers should describe exported preprocessors in
the corresponding {\tt NAME}.descr:

\begin{verbatim}
syntax foo {
  requires: bar, gni         // list of syntax dependencies
  pp: -parser o -printer p   // common options to asmpp and bytepp
  bytepp: ...
}
\end{verbatim}

\section{Milestones 7: Support of Multiple Compiler Versions}

This milestone focus on the support of multiple compiler versions.

\subsection{Compiler Description Files}

For each compiler version {\tt OVERSION}, the client and server states
will be extended with the following files:

\begin{itemize}
\item {\tt \$opam/compilers/OVERSION.comp}
\item {\tt \$opamserver/compilers/OVERSION.comp}
\end{itemize}

Each {\tt .comp} file contains:

\begin{itemize}

\item the location where this version can be downloaded. It can be an
  archive available via {\tt http} or using CVS such as {\tt svn} or
  {\tt git}.

\item eventual options to pass to the configure script. {\tt
  --prefix=\$opam/OVERSION/} will be automatically added to these
  options.

\item options to pass to {\tt make}.

\item eventual patch address, available via {\tt http} or locally on
  the filesystem

\end{itemize}

For instance, {\tt 3.12.1+memprof.comp} (OCaml version $3.12.1$ with
the memory profiling patch) looks like:

\begin{verbatim}
src:       http://caml.inria.fr/pub/distrib/ocaml-3.12/ocaml-3.12.1.tar.gz
build:     world world.opt
patches:   http://bozman.cagdas.free.fr/documents/ocamlmemprof-3.12.0.patch
\end{verbatim}

And {\tt trunk-tk-byte.comp} (OCaml from SVN trunk, with no {\em tk}
support and only in bytecode) looks like:

\begin{verbatim}
src:       http://caml.inria.fr/pub/distrib/ocaml-3.12/ocaml-3.12.1.tar.gz
configure: -no-tk
build:     world
\end{verbatim}

\subsection{Milestone 8: Version Pinning}

\subsection{Milestones 9: Parallel Build}

\subsection{Milestone 10: Version Comparison Scheme}

\subsection{Milestone 11: Database of Installed Files}


\end{document}
